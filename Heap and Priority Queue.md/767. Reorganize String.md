# 767. Reorganize String

## Approach 1 - （最优解法）

- time: O(N)
- space: O(1)

```java
class Solution {
    public String reorganizeString(String s) {
        int n = s.length();
        int[] freq = new int[26];

        for (char c : s.toCharArray()) freq[c - 'a']++;

        // 找最大频率字符
        int maxFreq = 0, maxChar = 0;
        for (int i = 0; i < 26; i++) {
            if (freq[i] > maxFreq) {
                maxFreq = freq[i];
                maxChar = i;
            }
        }

        // 可行性判断
        if (maxFreq > (n + 1) / 2) return "";

        char[] res = new char[n];
        int idx = 0;

        // 1️⃣ 先填最大频率字符（偶数位）
        while (freq[maxChar]-- > 0) {
            res[idx] = (char) (maxChar + 'a');
            idx += 2;
        }

        // 2️⃣ 填其他字符
        for (int i = 0; i < 26; i++) {
            while (freq[i]-- > 0) {
                if (idx >= n) idx = 1; // 切换到奇数位
                res[idx] = (char) (i + 'a');
                idx += 2;
            }
        }
        return new String(res);
    }
}
```

## Approach 2 - maxHeap

每一步都选“当前剩余最多、且不等于上一个字符的字符来放。用 prev 暂存上一个字符，强制它“冷却 1步。

1. 统计每一个task的频率
2. maxHeap来保证每次优先用频率最高的task
3. prev表示上一次用过的字符，这一轮不能用，但它不是永久禁止，只是延迟一轮
    - 上一个字符现在已经“冷却完 1 步”，且还没有用完，可以重新参与竞争了
    - 当前字符变成新的 prev
4. 返回时判断：return sb.length() == s.length() ? sb.toString() : "";
    - e.g s = "aaab", a太多， 不可能不相邻， 算法会在某一步， heap为空但是prev 还有剩余，while 结束， sb.length() < s.length()，返回 "" 正确

- time: 总时间复杂度：O(N + Nlog K) = O(N)
- space: O(K) = O(26) = O(1)

```java
class Solution {
    public String reorganizeString(String s) {
        int[] freq = new int[26];
        for (char c : s.toCharArray()) freq[c - 'a']++;

        PriorityQueue<int[]> pq = new PriorityQueue<>(
            (a, b) -> b[1] - a[1]
        );

        for (int i = 0; i < 26; i++) {
            if (freq[i] > 0) pq.offer(new int[]{i, freq[i]});
        }

        StringBuilder sb = new StringBuilder();
        int[] prev = null;

        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            sb.append((char)(cur[0] + 'a'));
            cur[1]--;

            if (prev != null && prev[1] > 0) {
                pq.offer(prev);
            }

            prev = cur;
        }

        return sb.length() == s.length() ? sb.toString() : "";
    }
}
```

## Appraoch 3 by Lei - 参照 621 Task scheduler simulation method (maxHeap) (好理解，慢，不推荐)

```java
class Solution {
    public String reorganizeString(String s) {
        int[] freq = new int[26];
        for (char c: s.toCharArray()) freq[c-'a']++;

        PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a,b) -> (b[1] - a[1]));
        for (int i= 0; i < 26; i++) {
            if (freq[i] > 0) {
                maxHeap.offer(new int[] {i, freq[i]});
            }
        }

        StringBuilder sb = new StringBuilder();
        while (!maxHeap.isEmpty()) {
            int cycle = 2;
            List<int[]> store = new ArrayList<>();

            while (cycle > 0 && !maxHeap.isEmpty()) {
                int[] cur = maxHeap.poll();
                char c = (char)(cur[0] + 'a')
                if (sb.length() > 0 && sb.charAt(sb.length()-1) == c) return "";
                sb.append(c);
                if (--cur[1] > 0) store.add(cur);
                cycle--;
            }

            if (store.size() > 0) maxHeap.addAll(store);
        }

        return sb.toString();
    }
}
```
