# 295. Find Median from Data Stream

## Approach 1 - Heap
![alt text](image-12.png)

- step 1: 通过constraints判断时间复杂度要求和可能用到的数据结构和方法：
    - “At most 5 * 10^4 calls will be made to addNum and findMedian", 10^4 * 10^4log(10^4), 用sort会超时，不能用sort.
    - 按O(logn) 单词操作，也就是说每次把数字加入到heap里面，不会超时
- e.g, 假设有四个数字： 5，8，6，7，需要知道6 and 7 去计算median
    - 我们需要把数字分成两半，leftHalf是6，5（maxHeap），右半边是7，8（minHeap)
    - addNum, 我们先把数字放入leftHalf, 把最大的pull放在右半边
        - 判读左右两边的size, 保持左边 size >= 右边，相差不超过1， 如果不是，右边size > 左边，则把右边的poll 放入左边
        - 两边size一样，说明有偶数个数
        - 两边size不一样，说明有奇数个数，我们规定左边放的数比右边多
    - find median: 
        - 两边size一样，则(rightHalf.peek() + leftHalf.peek())/2.0
        - 两边size不一样，说明有奇数个数，用leftHalf.peek(); 

- 时间复杂度：初始化和 findMedian 都是 O(1)，addNum 是 O(logq)，其中 q 是 addNum 的调用次数 每次操作堆需要 O(logq) 的时间。
- 空间复杂度：O(q)。

```java
class MedianFinder {
    private PriorityQueue<Integer> leftHalf;
    private PriorityQueue<Integer> rightHalf;

    public MedianFinder() {
        leftHalf = new PriorityQueue<>((a, b) -> b-a); // 最大堆
        rightHalf = new PriorityQueue<>(); // 最小堆
    }
    
    // leftHalf.size() 总是等于或者比 rightHalf.size() 多1
    public void addNum(int num) {
       if (leftHalf.size() == rightHalf.size()) {
            rightHalf.offer(num);
            leftHalf.offer(rightHalf.poll());
        } else {
            leftHalf.offer(num);
            rightHalf.offer(leftHalf.poll());
        }
    }
    
    public double findMedian() {
        int m = leftHalf.size();
        int n = rightHalf.size();
        return m > n? leftHalf.peek(): (leftHalf.peek() + rightHalf.peek())/2.0;
    }
}
```
## Follow up

If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?

### Appraoch - counting sort
所有整数都在 [0, 100] 这个固定、很小的范围内
    - 值域是常数（101 个可能值）
    - 不需要维护排序结构（堆 / BST）
    - 不存每个数，只存“每个数出现了多少次”，中位数就是“第 ⌈N/2⌉ 个数落在哪个桶里

```java
class MedianFinder {
    private int[] count; // Frequency array for numbers [0, 100]
    private int totalCount; // Total numbers added

    public MedianFinder() {
        count = new int[101]; // Since numbers range from 0 to 100
        totalCount = 0;
    }

    public void addNum(int num) {
        count[num]++; // count[i] = 数字 i 出现的次数
        totalCount++; // 数据流中元素总数
    }

    public double findMedian() {
        // 若 N 是奇数：第 (N+1)/2 个数
        // 若 N 是偶数：第 N/2 和 N/2 + 1 个数的平均值
        int mid1 = (totalCount + 1) / 2;  
        int mid2 = (totalCount % 2 == 0) ? mid1 + 1 : mid1; 
        
        int freqCount = 0;
        int median1 = -1, median2 = -1;

        // Iterate through the count array to find the median(s)
        for (int i = 0; i <= 100; i++) {
            freqCount += count[i]; // 到目前为止，一共有多少个数 ≤ i

            if (median1 == -1 && freqCount >= mid1) {
                median1 = i;
            }
            if (median2 == -1 && freqCount >= mid2) {
                median2 = i;
                break;
            }
        }

        return (median1 + median2) / 2.0;
    }
}


```