# 430. Flatten a Multilevel Doubly Linked List

## Approach 1 - DFS

![alt text](image-18.png)

- Actually, if we turn the above list in 90 degrees around the clock, then suddenly a binary tree appear in front of us. And the flatten operation is basically what we call preorder DFS traversal (Depth-First Search).
- Indeed, as shown in the above graph, we could consider the child pointer as the left pointer in binary tree which points to the left sub-tree (sublist). And similarly, the next pointer can be considered as the right pointer in binary tree. Then if we traverse the tree in preorder DFS, it would generate the same visiting sequence as the flatten operation in our problem.

![alt text](image-19.png)

![alt text](image-20.png)

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node prev;
    public Node next;
    public Node child;
};
*/

class Solution {
    public Node flatten(Node head) {
        if (head == null) return head;
        // dummy node to ensure the `prev` pointer is never none
        Node dummy = new Node(-1, null, head, null);

        dfs(dummy, head);

        // detach dummy from head
        dummy.next.prev = null;
        return  dummy.next;
    }

    /* return the tail of the flatten list */
    public Node dfs(Node prev, Node curr) {
        if (curr == null) return prev;
        curr.prev = prev;
        prev.next = curr;

        // the curr.next would be tempered in the recursive function
        Node tempNext = curr.next;

        Node tail = dfs(curr, curr.child);
        curr.child = null;

        return dfs(tail, tempNext);
    }
}

```