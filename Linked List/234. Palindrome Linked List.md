# 234. Palindrome Linked List

1. 用快慢指针找到链表中点
    - slow 每次走 1 步， fast 每次走 2 步， 当 fast 到尾部，slow 正好在中点
    - 链表长度为偶数， slow 最终位置为后半部分第一个节点
    - 链表长度为奇数， slow 最终位置为正中间的节点
2. 反转后半部分链表
3. 前半 & 后半逐个比较
    - 原始：1 → 2 → 3 → 2 → 1
    - 反转后半：1 → 2 → 3 ← 2 ← 1 (3.next = null)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode mid = findMiddleNode(head);
        ListNode head2 = reverseList(mid);

        while (head2 != null) {
            if (head.val != head2.val) return false;
            head = head.next;
            head2 = head2.next;
        }
        return true;
    }

    private ListNode findMiddleNode(ListNode head) {
        ListNode slow = head, fast = head;
        
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        return slow; // 如果是偶数个节点，停留在后半部分第一个点
    }

    private ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode cur = head;

        while (cur != null) {
            ListNode next = cur.next;
            cur.next = prev;
            prev = cur;
            cur = next;
        }
        return prev;
    }
}
```
- 时间复杂度：O(n)，其中 n 是链表的长度（节点个数）。
- 空间复杂度：O(1)