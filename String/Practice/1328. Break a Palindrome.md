# 1328. Break a Palindrome

给一个回文串 s, 允许只改一个字符（改成任意小写字母），让结果不再是回文，同时要求字典序尽可能小。若无解，返回空串。

## Intuition
- 若字符串长度为 1：无论把唯一字符改成啥，仍然是长度 1 的回文串；而且必须只改一次 → 无解，返回 ""。
- 为了让结果字典序最小，应该尽量让字符串前面的位置变得更小（字典序优先级从左到右）。
- 对于奇数长度，中间字符怎么改都不会影响回文对称性（它和自己对齐），单独改中间字符仍是回文 → 不能只动中间字符来“打破回文”。

## Approach 
- 如果遇到第一个不为 'a' 的字符，把它改成 'a'。这样能：
    - 打破回文（因为对应的右侧还是原字符）；
    - 并且由于在越靠左的位置做最小化改动，得到的字典序越小 → 这是全局最优。
- 如果前半段全是 'a'（意味着除了可能的中间位，其他成对字符都是 'a'），那么把最后一个字符改成 'b'。
    - 这时字符串形如 aaaa...a[中间?]aaaa...a，若想打破回文且尽量小，选择最靠右的位置做尽量小的增大（a -> b），对字典序影响最小。
- 注意loop是 length/2不是length, 否则 e.g "aba",改中间的b没用 仍然是对称的

```java
class Solution {
    public String breakPalindrome(String palindrome) {
        int length = palindrome.length();
        if (length == 1) { 
            return "";
        }
        // Strings are immutable in Java, convert it into a char array
        char[] palindromeArray = palindrome.toCharArray();
        
        for (int i = 0; i < length / 2; i++) { //非常爱错是 length/2不是length
            if (palindromeArray[i] != 'a') {
                palindromeArray[i] = 'a';
                return String.valueOf(palindromeArray);
            }
        }
        
        palindromeArray[length - 1] = 'b';
        return String.valueOf(palindromeArray);
    }
}

```