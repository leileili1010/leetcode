# 658. Find K Closest Elements

## Approach 1 by Lei

```java
class Solution {
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        List<Integer> res = new ArrayList<>();
        
        int right = binarySearch(arr, x); //0
        int left = right-1; 
        int n = arr.length; //6

        for (int i = 0; i < k && i < arr.length; i++) {
            if (left >= 0 && (right >= n || Math.abs(arr[left]-x) <= Math.abs(arr[right]-x))) {
                res.add(0, arr[left--]);
            } else {
                res.add(arr[right++]); 
            }
        }

        return res;
    }

    private int binarySearch(int[] arr, int target) {
        int start = 0, end = arr.length;

        while (start < end) {
            int mid = start + (end - start)/2;
            if (arr[mid] > target) {
                end = mid;
            } else if (arr[mid] < target) {
                start = mid + 1;
            } else {
                return mid;
            }
        }

        return start;
    }
}
```

## Appraoch 2 - jiuzhang
- 和第一种方法原理一样， 只是用的helper function

```java
class Solution {
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        List<Integer> res = new ArrayList<>();
        int right = binarySearch(arr, x);
        int left = right - 1;

        // 左右指针相背而行
        for (int i = 0; i < k && i < arr.length; i++) {
            if (isLeftCloser(arr, x, left, right)) {
                res.add(0, arr[left--]); //注意是left--, 且left每次要插到index 0 位置
            } else {
                res.add(arr[right++]);
            }
        }
        return res;
    }

    private int binarySearch(int[] arr, int target) {
        // 找到 >= target的最左边
        int start = 0, end = arr.length-1;
        
        while (start + 1 < end) {
            int mid = start + (end - start)/2;

            if (arr[mid] < target) {
                start = mid;
            } else {
                end = mid;
            }
        }
        
        if (arr[start] >= target) return start;
        if (arr[end] >= target) return end;
        return arr.length;
    }

    // 判断加入哪个
    private boolean isLeftCloser(int[] arr, int target, int left, int right) {
        if (left < 0) return false;
        if (right >= arr.length) return true;
        return target - arr[left] <= arr[right] - target;
    }
}
```

## 另一种写法（推荐）

## 核心思路（一定要先理解）
这道题乍一看会很复杂，但其实题目给出了一个非常重要的提示：  
**数组是有序的**。

只要看到“有序数组 + 查找某个位置”，  
**第一时间就应该想到用 Binary Search**。

一旦想到二分，这题瞬间变得非常直观，只需要分两步：


### ✨ 第一步：用 Binary Search 找“插入位置左侧最接近 x 的 index”
我们并不是要真的把 `x` 插进去，而是要找到：

> **如果要把 x 插入 arr，它应该落在的位置的左边那一个 index**

例如：  
`arr = [1,2,3,4,5], x = 3`  
那最接近的左边就是 `2`（值为 2），右边就是 `3`（值为 3）。

我们要找的不是真实的元素，而是：
- **左指针 left**（指向 ≤ x 的最右侧元素）
- **右指针 right = left + 1**

这两个指针就代表了“离 x 最近的两侧起点”。

Binary Search 完全可以找到这个左边界，因为有序数组能让我们快速定位。

### 第二步：双指针扩散（背向双指针）
当我们拿到：left → 最接近 x 的左边, right → 最接近 x 的右边

下一步就是：

> **双指针往左右扩散，谁更接近 x 就选谁**

- 如果左边更近 → `left--`
- 如果右边更近 → `right++`

这种“背向扩散”的方式就会不断找到距离 x 最近的元素。

我们重复选 k 次即可。

### 第三个细节：输出必须是递增的（有序）
题目要求最终输出的 list 必须从小到大排列。

由于：
- 左边的选择应该排在前面
- 右边的选择应该排在后面

所以：
- **如果取的是左边 → 使用 `res.add(0, arr[left])`**
- **如果取的是右边 → 使用 `res.add(arr[right])`**

这样就保证最终返回结果是严格从小到大排序的，无需额外排序。

```java
class Solution {
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        int left = binarySearch(arr, x);
        int right = left + 1;
        List<Integer> res = new ArrayList<>();

        for (int i = 0; i < k; i++) {
            if (isLeftcloser(arr, left, right, x)) {
                res.add(0, arr[left--]);
            } else {
                res.add(arr[right++]);
            }
        }
        return res;
    }

    private int binarySearch(int[] arr, int x) {
        int left = 0, right = arr.length-1;
        int res = 0;

        while (left <= right) {
            int mid = left + (right-left)/2;

            if (arr[mid] <= x) {
                left = mid + 1;
                res = mid;
            } else {
                right = mid-1;
            }
        }
        return res;
    } 

    private boolean isLeftcloser(int[] arr, int left, int right, int target) {
        if (left < 0) return false;
        if (right >= arr.length) return true;
        return Math.abs(arr[left]-target) <= Math.abs(arr[right]-target);
    }
}
```
- time: O(logn + k);
- space: O(k)