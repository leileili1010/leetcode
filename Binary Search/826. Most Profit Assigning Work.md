# 826. Most Profit Assigning Work

## Approach 1 - sorting + Greedy + two pointers (推荐)
![alt text](image-27.png)

### 🧠 题意总结（简洁）
- 每个 **job** 有 `(difficulty[i], profit[i])`。
- 每个 **worker** 有自己的能力值 `worker[j]`。
- 一个 worker **只能做自己能力范围内（difficulty ≤ ability）** 的工作。
- Worker 会选 **能做的工作里 profit 最大的那一个**。
- 最终输出所有 worker 能拿到的最大 profit 的 **总和**。


### 💡 核心思路
这题看起来像是用 binary search 找每个 worker 能做的最高 difficulty 工作，但最佳写法其实是：

**Sorting + Two Pointers + Greedy（最容易写、最不容易错）**

关键点：

1. **把 jobs 组合成一个 pair 数组**：  
   `jobs[i] = {difficulty[i], profit[i]}`  
   ——这样就能按 difficulty 排序，同时知道对应 profit。

2. **将 jobs 按 difficulty 升序排序**  
   因为 worker 是从低能力到高能力遍历，难度小的工作应该先出现。

3. **worker 数组也按能力升序排序**  
   这样每个 worker 处理的时候，job 的指针只会往右走，不会回头。

4. 遍历 worker 时维持一个变量：  
   **`bestProfitSoFar` = 当前 worker 能做的所有 job 中 profit 的最大值**

5. 用一个指针 `j` 扫 jobs：  
   - 只要当前 job 的 difficulty ≤ worker 的能力  
     → 就更新 `bestProfitSoFar`  
   - job 指针永远不回退（O(N) 高效）

6. 最后：  
   对于每个 worker 加上 `bestProfitSoFar`


### 🏗️ 正确的算法步骤（最终版）
1. 把 `(difficulty, profit)` 合并到 `jobs` 数组
2. 对 jobs 按 difficulty 升序排序
3. 对 worker 数组升序排序
4. 遍历 worker（从小到大）  
   - 用 job 指针 `j` 走到 worker 能做的最大难度  
   - 更新 `bestProfitSoFar`  
   - 把这个值加入总 profit
5. 返回最终总和

---

### ✅ 为什么 worker 也要排序？
假设 worker 是随机顺序：

- worker 能力是 `[3, 5, 1, 8]`  
- 如果不排序，job 指针需要不停来回移动 → 很不好写，而且必须做 binary search。

**排序后** 是升序：

`[1, 3, 5, 8]`

这样 job 指针只会往右走，不会回头，逻辑最干净。


### 🧠 为什么是 Greedy？
因为 worker 能做的 job 是 difficulty ≤ ability 的所有 job，它选择 profit 最大的就行。

而当 worker 按能力从小到大时：

- `bestProfitSoFar` 会越来越大，不需要重算  
- job 指针也只会往前走

这就是典型的 greedy + two pointers。


```java
class Solution {
    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {
        int n = difficulty.length;
        int[][] jobs = new int[n][2];

        // create pairs: [difficulty, profit]
        for (int i = 0; i < n; i++) {
            jobs[i][0] = difficulty[i];
            jobs[i][1] = profit[i];
        }

        // sort jobs by difficulty
        Arrays.sort(jobs, (a, b) -> a[0] - b[0]); // Nlogn

        // sort workers by ability
        Arrays.sort(worker); // Mlogm

        int res = 0;
        int bestProfitSoFar = 0; // 这里一定要define在外面 比如一些diffculty低的工作有可能钱更多 这时候我们就应该比较当下这个difficulty 和 bestProfitSoFar
        int j = 0;  // job pointer
        
        // for each worker from weakest to strongest
        for (int w : worker) { // O(n + m)
            while (j < n && jobs[j][0] <= w) {
                bestProfitSoFar = Math.max(bestProfitSoFar, jobs[j][1]);
                j++;
            }
            res += bestProfitSoFar;
        }

        return res;
    }
}
```

- time: O(Nlogn+Mlogm)
- space: O(N)

## Approach 2 - binary search + two pointers + greedy

```java
class Solution {

    public int maxProfitAssignment(
        int[] difficulty,
        int[] profit,
        int[] worker
    ) {
        List<int[]> jobProfile = new ArrayList<>();
        jobProfile.add(new int[] { 0, 0 });
        for (int i = 0; i < difficulty.length; i++) {
            jobProfile.add(new int[] { difficulty[i], profit[i] });
        }

        // Sort by difficulty values in increasing order.
        Collections.sort(jobProfile, (a, b) -> Integer.compare(a[0], b[0]));
        for (int i = 0; i < jobProfile.size() - 1; i++) {
            jobProfile.get(i + 1)[1] = Math.max(
                jobProfile.get(i)[1],
                jobProfile.get(i + 1)[1]
            );
        }

        int netProfit = 0;
        for (int i = 0; i < worker.length; i++) {
            int ability = worker[i];

            // Find the job with just smaller or equal difficulty than ability.
            int l = 0, r = jobProfile.size() - 1, jobProfit = 0;
            while (l <= r) {
                int mid = (l + r) / 2;
                if (jobProfile.get(mid)[0] <= ability) {
                    jobProfit = Math.max(jobProfit, jobProfile.get(mid)[1]);
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }

            // Increment profit of current worker to total profit.
            netProfit += jobProfit;
        }
        return netProfit;
    }
}
```