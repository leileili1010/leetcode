# 826. Most Profit Assigning Work

## Approach 1 - sorting + Greedy + two pointers (推荐)
![alt text](image-27.png)

```java
class Solution {
    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {
        int n = difficulty.length;
        int[][] jobs = new int[n][2];

        // create pairs: [difficulty, profit]
        for (int i = 0; i < n; i++) {
            jobs[i][0] = difficulty[i];
            jobs[i][1] = profit[i];
        }

        // sort jobs by difficulty
        Arrays.sort(jobs, (a, b) -> a[0] - b[0]); // Nlogn

        // sort workers by ability
        Arrays.sort(worker); // Mlogm

        int res = 0;
        int bestProfitSoFar = 0; // 这里一定要define在外面 比如一些diffculty低的工作有可能钱更多 这时候我们就应该比较当下这个difficulty 和 bestProfitSoFar
        int j = 0;  // job pointer
        
        // for each worker from weakest to strongest
        for (int w : worker) { // O(n + m)
            while (j < n && jobs[j][0] <= w) {
                bestProfitSoFar = Math.max(bestProfitSoFar, jobs[j][1]);
                j++;
            }
            res += bestProfitSoFar;
        }

        return res;
    }
}
```

- time: O(Nlogn+Mlogm)
- space: O(N)

## Approach 2 - binary search + two pointers + greedy

```java
class Solution {

    public int maxProfitAssignment(
        int[] difficulty,
        int[] profit,
        int[] worker
    ) {
        List<int[]> jobProfile = new ArrayList<>();
        jobProfile.add(new int[] { 0, 0 });
        for (int i = 0; i < difficulty.length; i++) {
            jobProfile.add(new int[] { difficulty[i], profit[i] });
        }

        // Sort by difficulty values in increasing order.
        Collections.sort(jobProfile, (a, b) -> Integer.compare(a[0], b[0]));
        for (int i = 0; i < jobProfile.size() - 1; i++) {
            jobProfile.get(i + 1)[1] = Math.max(
                jobProfile.get(i)[1],
                jobProfile.get(i + 1)[1]
            );
        }

        int netProfit = 0;
        for (int i = 0; i < worker.length; i++) {
            int ability = worker[i];

            // Find the job with just smaller or equal difficulty than ability.
            int l = 0, r = jobProfile.size() - 1, jobProfit = 0;
            while (l <= r) {
                int mid = (l + r) / 2;
                if (jobProfile.get(mid)[0] <= ability) {
                    jobProfit = Math.max(jobProfit, jobProfile.get(mid)[1]);
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }

            // Increment profit of current worker to total profit.
            netProfit += jobProfit;
        }
        return netProfit;
    }
}
```