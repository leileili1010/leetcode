# 153. Find Minimum in Rotated Sorted Array

## Approach - binary search
升序数组在旋转之后（从后往前旋转）被分成两部分，大的一半和小的一半，大的一半里面每一个数字都比小的一半大，每一半内部多是按升序排列的
- 最小值的特点是它是唯一一个比前面数小的数字
- 用二分搜索找到最小值: 
    - 很自然的我们会想到判断条件是nums[mid]和nums[mid-1] or nums[mid+1]，但是当target在最右边或最左边时就会出错或写起来很麻烦，所以我们用nums[mid]和nums[n-1]比较
        - nums[mid] > nums[n-1], mid在大的一半，需要start pointer往左边移动
        - nums[mid] < nums[n-1], mid在小的一半，继续向右移动去找到最小值
    - binary searh 有三个模板，用start + 1 < end这个比较好，因为永远不会出界
        - 这道题不太适用 left <= right的模板，因为它没有中途return mid的条件，而是区间收敛到一个点，用left <= right可能会出界或陷入循环，就很难写

### 写法一 - 推荐
```java
class Solution {
    public int findMin(int[] nums) {
        int start = 0, end = nums.length-1;

        while (start + 1 < end) {
            int mid = start + (end - start)/2;

            if (nums[mid] > nums[end]) {// The min must be to the right of mid
                start = mid;
            } else {  // The min is at mid or to the left of mid
                end = mid;
            }
        }

        return Math.min(nums[start], nums[end]);
    }
}
```
### 写法二
```java
class Solution {
    public int findMin(int[] nums) {
        int left = 0, right = nums.length - 1;

        while (left < right) {
            int mid = left + (right - left) / 2;

            // The min must be to the right of mid
            if (nums[mid] > nums[right]) {
                left = mid + 1;
            } else {
                // The min is at mid or to the left of mid
                right = mid;
            }
        }

        // left == right → pointing to the smallest element
        return nums[left];
    }
}

```