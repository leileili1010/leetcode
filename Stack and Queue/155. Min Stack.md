# 155 Min Stack

## Approach 21 - one stack (recommended)

```java
class MinStack {
    private Deque<int[]> stack = new ArrayDeque<>(); // int[num, min]

    public MinStack() {
        stack = new ArrayDeque<>();
    }
    
    public void push(int val) {
        int min = stack.isEmpty()? val: Math.min(val, stack.peek()[1]);
        stack.push(new int[]{val, min}); 
    }
    
    public void pop() {
        stack.pop();
    }
    
    public int top() {
        return stack.peek()[0];
    }
    
    public int getMin() {
        return stack.peek()[1];
    }
}
```

还有一种写法, 类似于加一个哨兵节点，用不上但是方便比较，可以不用区分stack.isEmpty() or not;

```java
class MinStack {
    private Deque<int[]> stack = new ArrayDeque<>(); // int[num, min]

    public MinStack() {
        stack = new ArrayDeque<>();
        stack.push(new int[] {0, Integer.MAX_VALUE}); // 哨兵节点
    }
    
    public void push(int val) {
        stack.push(new int[]{val, Math.min(val, stack.peek()[1])}); 
    }
    
    public void pop() {
        stack.pop();
    }
    
    public int top() {
        return stack.peek()[0];
    }
    
    public int getMin() {
        return stack.peek()[1];
    }
}
```