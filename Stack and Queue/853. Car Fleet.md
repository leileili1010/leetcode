# 853. Car Fleet
https://leetcode.com/problems/min-stack/
## 题目
- 有一个终点 target。
- 有多辆车，每辆车有：
    - 起始位置 position[i]
    - 行驶速度 speed[i]
- 规则：
    - 所有车都向 target 前进（同一方向）。
    - 如果后车速度更快，它会追上前车。
    - 一旦后车追上前车，它们会以前车的速度继续一起前进（形成车队 fleet）。
    - 车队中的车不会再彼此超过，也不会分开。
    - 你要计算最终有多少个车队能到达目标。

## 思路
- 构造一个Car class, 有speed，position 和 timeToTarget（double） 这些属性
- 构造一个Car数组，按position从小到大排序
- 从positin 最大的开始loop
    - 比较当前时间和前一个positin的时间，
    - 如果时间当前时间 < 前一个，说明离target更近的position速度还更快，后面的车不可能赶上，res++;
    - 否则就合并

- time: O(NlogN)
- space: O(N)
## Appraoch 1 - Array

```java
class Car {
    int position;
    double timeToTarget;
    int speed;

    Car(int position, int speed) {
        this.position = position;
        this.speed = speed;
    }
}

class Solution {
    public int carFleet(int target, int[] position, int[] speed) {
        int n = position.length;
        Car[] cars = new Car[n];

        for (int i = 0; i < n; i++) {
            cars[i] = new Car(position[i], speed[i]);
            cars[i].timeToTarget = (double) (target-position[i])/speed[i];
        }  

        Arrays.sort(cars, (a,b) -> (a.position-b.position));

        int res = 1; // 至少有一个车队，如果我们只有一个car, 它自己就是一个车队
        for (int i = n-1; i > 0; i--) {
            if (cars[i].timeToTarget < cars[i-1].timeToTarget) res++;
            else cars[i-1] = cars[i]; //  后面的车追上之后变成一个车队了
        }

        return res;
    }
}
```


## Approach 2 - stack

```java
class Car {
    int position;
    int speed;
    double timeToDestination;

    Car(int position, int speed) {
        this.position = position;
        this.speed = speed;
    }
}

class Solution {
    public int carFleet(int target, int[] position, int[] speed) {
        int n = position.length;

        Car[] cars = new Car[n];

        // 1. 构造 Car 对象
        for (int i = 0; i < n; i++) {
            cars[i] = new Car(position[i], speed[i]);
            cars[i].timeToDestination = (double)(target - position[i]) / speed[i];
        }

        // 2. 按 position 从小到大排序（靠后 → 靠前）
        Arrays.sort(cars, (a, b) -> a.position - b.position);

        // 3. 必须从右往左处理 → stack 只放 time
        Deque<Double> stack = new ArrayDeque<>();

        // 从最右边（靠近 target）开始
        for (int i = n - 1; i >= 0; i--) {
            double t = cars[i].timeToDestination;

            // 如果当前车时间 > stack.peek()，说明追不上 → 新车队
            if (stack.isEmpty() || t > stack.peek()) {
                stack.push(t);
            }
            // 否则（t <= stack.peek()），说明它能追上 → 属于现有车队
            else {
                // do nothing
            }
        }

        return stack.size();
    }
}
```

