# 456. 132 Pattern

## Approach 1 - 单调栈

这是一道代码简单但是思维难度大的题目。要求是是有索引 i < j < k, 同时 num[i] < nums[k] < nums[j], 及中间的index是最大数，第一个index i是最小数， 第三个index k对应的是第二大的数

### 思路
单调栈同时从右往左扫描很巧妙的就是会先找到j, k, 放到栈里的是j, 弹出来的是k, 再能扫描到要给比nums[k]小的数答案就是true了

1. 初始化
    - 单调栈：从右到左扫描数组，存储的是索引**j**对应的数（最大的数nums[j]），**单调递减**
    
2. **从右往左**遍历，找到j, k, i
    - 下一个数如果小于上一个，继续放入单调栈，如果不是就一直弹出来作为nums[k]， k 必须是右侧所有比 nums[j] 小的数字中最大的那个，如果只弹出一次是错的，要一直弹出，知道num[i] <= stack.peek();
    - 再找到k的情况下，如果再扫描到一个数字是小于nums[k], 那我们就找到答案了, return true;
3. 没有找到答案return false

- time O(N)
- space O(N)

```java
class Solution {
    public boolean find132pattern(int[] nums) {
        int n = nums.length;

        // 单调递减栈：存的是“未来可能当 nums[j] 的数字”
        Deque<Integer> stack = new ArrayDeque<>();

        // numK 表示已经找到的“合法的 nums[k]”，且是目前最大的那个 k
        int numK = Integer.MIN_VALUE;

        // 从右往左扫描
        for (int i = n - 1; i >= 0; i--) {

            // 如果 nums[i] < numK，已经找到 1 < 3 < 2，也就是 132
            if (nums[i] < numK) {
                return true;
            }

            // nums[i] 作为一个大的数（可能当 nums[j]）
            // 把栈中比 nums[i] 小的值弹出来
            // 这些被弹出的值就是有效的 “nums[k]”
            while (!stack.isEmpty() && stack.peek() < nums[i]) {
                numK = stack.pop(); // 更新当前最大的 km
            }

            // 当前 nums[i] 比 maxK 大，因此它可以作为潜在的 nums[j]
            stack.push(nums[i]);
        }

        return false;
    }
}


```