# 456. 132 Pattern

## Approach 1 - 单调栈

这是一道代码简单但是思维难度大的题目。要求是是有索引 i < j < k, 同时 num[i] < nums[k] < nums[j], 及中间的index是最大数，第一个index i是最小数， 第三个index k对应的是第二大的数

### 思路

1. 初始化
    - 单调栈：从右到左扫描数组，存储的是索引**j**对应的数（最大的数nums[j]），**单调递减**
    
2. **从右往左**遍历，找到j, k, i
    - 下一个数如果小于上一个，继续放入单调栈，如果不是就弹出来作为nums[k]
    - 再找到k的情况下，如果再扫描到一个数字是小于nums[k], 那我们就找到答案了, return true;
3. 没有找到答案return false

- time O(N)
- space O(N)

```java
class Solution {
    public boolean find132pattern(int[] nums) {
        int n = nums.length;

        // 单调递减栈：存的是“未来可能当 nums[j] 的数字”
        Deque<Integer> stack = new ArrayDeque<>();

        // maxK 表示已经找到的“合法的 nums[k]”，且是目前最大的那个 k
        int maxK = Integer.MIN_VALUE;

        // 从右往左扫描
        for (int i = n - 1; i >= 0; i--) {

            // 如果 nums[i] < maxK，已经找到 1 < 3 < 2，也就是 132
            if (nums[i] < maxK) {
                return true;
            }

            // nums[i] 作为一个大的数（可能当 nums[j]）
            // 把栈中比 nums[i] 小的值弹出来
            // 这些被弹出的值就是有效的 “nums[k]”
            while (!stack.isEmpty() && stack.peek() < nums[i]) {
                maxK = stack.pop(); // 更新当前最大的 km
            }

            // 当前 nums[i] 比 maxK 大，因此它可以作为潜在的 nums[j]
            stack.push(nums[i]);
        }

        return false;
    }
}


```