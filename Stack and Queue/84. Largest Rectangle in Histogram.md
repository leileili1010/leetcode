# 84 Largest Rectangle in Histogram

## Approach - Monotonic Increasing Stack

单调栈，用于找到数组种某个数右边或者左边离他它最近的最小或者最大的数。对于数组中的每个数，我们希望他们可以同时往左和往右去拓展，直到遇到第一个比它小的数字

[2, 1, 5, 6, 2, 3], 以最后一个2为例，我们希望2往左和往右拓展， 往左直到遇到1停下来，往右一直到3， 5，6，2，3 是以2为最短的板能构成的最大面积

1. 高度：枚举height, 把数组中的每一个数当成是最短板，以它为高度来计算面积，height[i]
2. 宽度：
    - right = 往右离i最近的比i小的数的index
    - left =  往左离i最近的比i小的数的index
3. 
+


### 写法 1

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        Deque<Integer> stack = new ArrayDeque<>();
        int max = 0;
        int N = heights.length;

        for (int i = 0; i <= N; i++) {
            int curHeight = i == N? 0: heights[i];

            while (!stack.isEmpty() && curHeight < heights[stack.peek()]) {
                int height = heights[stack.pop()];
                int width = stack.isEmpty()? i: i - stack.peek()-1;
                max = Math.max(max, height * width);
            }
            stack.push(i);
        }
        return max;
    }
}
```


### 写法 2：

- stack.push(-1) is a key step to simpify width calculation
- 另一个计算width的诀窍是是 i减去pop之后的前面一个indx, 这样能保证这个完整的向右边extend 同时也不用存一个node同时还要update indx用于计算width

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        Deque<Integer> stack = new ArrayDeque<>();
        stack.push(-1); // Add a sentinel idx of -1 at the beginning to simpify width calculation
        int max = 0, N = heights.length;

        for (int i = 0; i < N; i++) {
            while (stack.peek() != -1 && heights[stack.peek()] >= heights[i]) {
                int preHeight = heights[stack.pop()];
                int width = i - stack.peek() - 1;
                max = Math.max(max, preHeight * width);
            }
            stack.push(i);
        }

        while (stack.peek() != -1) {
            int preHeight = heights[stack.pop()];
            int width = N - stack.peek() - 1;
            max = Math.max(max, preHeight * width);
        }

        return max;
    }
}
```

### 写法 3：

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        Deque<int[]> stack = new ArrayDeque<>();
        int max = 0, N = heights.length;

        for (int i = 0; i < N; i++) {
            int start = i;
            while (!stack.isEmpty() && stack.peek()[1] > heights[i]) {
                start = stack.peek()[0];
                int size = sizeCalulator(stack, i);
                max = Math.max(size, max);
            }
            stack.push(new int[]{start, heights[i]});
        }   
        
        while (!stack.isEmpty()) {
            int size = sizeCalulator(stack, N);
            max = Math.max(size, max);  
        }

        return max;
    }

    private int sizeCalulator(Deque<int[]> stack, int N) {
        int[] cur = stack.pop();
        int height = cur[1];
        int idx = cur[0];
        int size = height * (N - idx);
        return size;
    }
}
```

### 写法 4：

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        Deque<int[]> stack = new ArrayDeque<>();
        int max = 0, N = heights.length;

        for (int i = 0; i < N; i++) {
            if (!stack.isEmpty() && heights[i] < stack.peek()[1]) {
                int idx = 0;
                while (!stack.isEmpty() && stack.peek()[1] > heights[i]) {
                    int[] cur = stack.pop();
                    int height = cur[1];
                    idx = cur[0];
                    int size = height * (i - idx);
                    max = Math.max(size, max);  
                }
                stack.push(new int[]{idx, heights[i]});
                continue;
            } 
                
            stack.push(new int[]{i, heights[i]});
        }   
        
        while (!stack.isEmpty()) {
            int[] cur = stack.pop();
            int height = cur[1];
            int idx = cur[0];
            int size = height * (N - idx);
            max = Math.max(size, max);  
        }

        return max;
    }
}
```
