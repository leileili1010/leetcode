# 84 Largest Rectangle in Histogram

## Approach - Monotonic Increasing Stack

单调栈，用于找到数组种某个数右边或者左边离他它最近的最小或者最大的数。对于数组中的每个数，我们希望他们可以同时往左和往右去拓展，直到遇到第一个比它小的数字

[2, 1, 5, 6, 2, 3], 以最后一个2为例，我们希望2往左和往右拓展， 往左直到遇到1停下来，往右一直到3， 5，6，2，3 是以2为最短的板能构成的最大面积

1. 高度：枚举height, 把数组中的每一个数当成是最短板，以它为高度来计算面积，高度 = height[i]
2. 宽度：
    - right = 往右离i最近的比i小的数的index
    - left =  往左离i最近的比i小的数的index
    - 宽度 = right - left - 1;
3. 

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        Deque<Integer> stack = new ArrayDeque<>(); // index
        int max = 0;
        int N = heights.length;

        // right <= N, 因为把n-1放入之后就结束了不会再计算了，必须再来一个n才会继续计算
        for (int right = 0; right <= N; right++) {
            int curHeight = right == N? -1: heights[right];

            while (!stack.isEmpty() && curHeight < heights[stack.peek()]) {
                int height = heights[stack.pop()];
                int left = stack.isEmpty()? -1: stack.peek();
                int width = right - left - 1
                max = Math.max(max, height * width);
            }
            stack.push(i);
        }
        return max;
    }
}
```
- a slight different 写法

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        Deque<Integer> stack = new ArrayDeque<>();
        stack.push(-1); // 在栈中只有一个数的时候，栈顶的「下面那个数」是 -1，对应 left[i] = -1 的情况
        int ans = 0;
       
        for (int right = 0; right <= n; right++) {
            int h = right < n ? heights[right] : 0;
            
            while (stack.size() > 1 && heights[stack.peek()] >= h) {
                int i = stack.pop(); // 矩形的高（的下标）
                int left = stack.peek(); // 栈顶下面那个数就是 left
                ans = Math.max(ans, heights[i] * (right - left - 1));
            }
            stack.push(right);
        }
        
        return ans;
    }
}
```
