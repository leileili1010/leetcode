# 496. Next Greater Element I

## Approach 1 - 单调栈

```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        int n = nums1.length;
        int[] res = new int[n];
        Arrays.fill(res, -1);
        
        // 1. 哈希表存储对应的nums1的数字和索引
        Map<Integer, Integer> map = new HashMap<>(n, 1);
        for (int i = 0; i < n; i++) {
            map.put(nums1[i], i);
        }

        // 2. nums2做单调栈处理（模板）
            // pop元素时需要grap nums1 index 然后更新res
            // 技巧是只往单调栈里面放入nums1的数字，不是的话就不放
        Deque<Integer> stack = new ArrayDeque<>(); // descending order
        for (int num: nums2) { // num = 4
            while (!stack.isEmpty() && num > stack.peek()) {
                int top = stack.pop(); // 3
                res[map.get(top)] = num;
            }
            if (map.containsKey(num)) stack.push(num);
        }
        return res;
    }
}
```
- 时间复杂度：O(n+m)，其中 n 是 nums1的长度，m 是 nums2 的长度。
- 空间复杂度：O(n)。由于只把在 nums1中的元素入栈，所以栈的大小不会超过 n。

