# 645. Set Mismatch

## Approach 1 - using extra array （容易想到，好写）

- time: O(N)
- space: O(N)

```java
class Solution {
    public int[] findErrorNums(int[] nums) {
        int n = nums.length;
        boolean[] exists = new boolean[n+1];
        int[] res = new int[2];

        for (int num: nums) {
            if (exists[num]) {
                res[0] = num;
            }
            exists[num] = true;
        }

        for (int i = 1; i < exists.length; i++) {
            if (!exists[i]) {
                res[1] = i;
                break;
            }
        }

        return res;
    }
}
```

## Approach 2 - 最优解(非常巧妙的方法)： in-place marking

- time: O(N)
- space: O(1)

1. 先找duplicate:
    - 遍历把数字改成负数，如果下次遇到的数字是负数，则找到了duplicate
2. 找missing:
    - 数组 nums 长度是 n， 合法数字范围是 [1, n]， nums[value - 1] 来表示 数字 value 是否出现过
    - 如果某个数字 v 从未出现
    - nums[i], i.e nums[v - 1] 从来没有被乘以 -1， 所以它 仍然是正数 , i = v-1
    - missing = v = i + 1
```java
class Solution {
    public int[] findErrorNums(int[] nums) {
        int dup = -1, missing = 1;
        for (int n: nums) {
            if (nums[Math.abs(n) - 1] < 0)
                dup = Math.abs(n); // 第二次看到 → 重复数
            else
                nums[Math.abs(n) - 1] *= -1; // // 第一次看到 → 标记为出现过
        }

        for (int i = 1; i < nums.length; i++) {
            if (nums[i] > 0)
                missing = i + 1;
        }

        return new int[]{dup, missing};
    }
}
```