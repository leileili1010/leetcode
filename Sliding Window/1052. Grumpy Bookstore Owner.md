
# 1052. Grumpy Bookstore Owner
- time: O(N)
- space: O(1)

## Approach 

这道题的解法非常巧妙，核心分为两部分：  
1. **初始化计算 base 满意顾客数**  
2. **滑动窗口计算额外可挽回的顾客数**

---

- Step 1. Base Calculation 首先我们要计算一个 **base** 的 `customer satisfaction`。  
    - 在前 `minutes` 这个窗口内，**无论老板是否 grumpy**，顾客都可以被满意（因为我们可以选择把这个窗口设为不 grumpy）。  
        - 因此在 `i < minutes` 的时候，我们直接把 `customers[i]` 加到 sum 里。  
        - 对于其他位置 `i >= minutes`，则根据 `grumpy[i]` 来决定是否加：  
        - 如果 `grumpy[i] = 0`，顾客本来就满意 → 可以加  
        - 如果 `grumpy[i] = 1`，顾客本来不满意 → 不加  
        - sum += (1 - grumpy[i]) * customers[i]

- Step 2. Sliding Window 接下来是主要的 **滑动窗口实现**
    - 用 `i` 作为右指针，从 `minutes` 开始循环（因为前 `minutes` 已经算过了）。
    - 👉 窗口扩展
        - 当窗口右移到新的位置 `i` 时：
        - 如果 `grumpy[i] == 1`，说明这个顾客原本不满意，但因为进入了窗口，可以被挽回，所以：
        - sum += customers[i]
    - 👉 窗口收缩
        - 当窗口左端 `left` 向右移动时：
        - 如果 `grumpy[left] == 1`，说明这个顾客原本是通过窗口被挽回的，但现在窗口缩小了，他就不能再被挽回，需要减掉：
        - sum -= customers[left], left++
```java
class Solution {
    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {
        int n = customers.length; // 4
        int sum = 0;

        // 初始化
        for (int i = 0; i < n; i++) { 
            if (i < minutes) { 
                sum += customers[i];
            } else {
                sum += (1-grumpy[i]) * customers[i]; 
            }
        } // sum = 8

        int left = 0, res = sum; // res = 8
        for (int i = minutes; i < n; i++) { // i = 3
            if (grumpy[i] == 1) sum += customers[i]; // sum = 23
            if (grumpy[left] == 1) sum -= customers[left]; // left = 2
            res = Math.max(res, sum); // res = 14
            left++; 
        }

        return res;
    }
}
```