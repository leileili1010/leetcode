# 395. Longest Substring with At Least K Repeating Characters

## Approach 1 - Divide and Conquer

![alt text](image-12.png)

The string would be split only when we find an invalid character. An invalid character is the one with a frequency of less than k. As we know, the invalid character cannot be part of the result, we split the string at the index where we find the invalid character, recursively check for each split, and combine the result.
- Build the countMap with the frequency of each character in the string s.
- Find the position for mid index by iterating over the string. The mid index would be the first invalid character in the string.
- To make it more efficient, we ignore all the invalid characters after the mid index as well, thereby reducing the number of recursive calls.
    - aabcdxxx, mid = b, midnext = x, 中间cd被跳过更efficiet, 因为他们本身也不valid, 所以不用以它们为mid来分，直接跳过
- Split the string into 2 substrings at the mid index and recursively find the result.

```java
class Solution {
    public int longestSubstring(String s, int k) {
        return longestSubstringUtil(s, 0, s.length(), k);
    }

    int longestSubstringUtil(String s, int start, int end, int k) {
        if (end < k) return 0;
        int[] countMap = new int[26];
        // update the countMap with the count of each character
        for (int i = start; i < end; i++)
            countMap[s.charAt(i) - 'a']++;
        
        for (int mid = start; mid < end; mid++) {
            if (countMap[s.charAt(mid) - 'a'] >= k) continue;
            int midNext = mid + 1;
            while (midNext < end && countMap[s.charAt(midNext) - 'a'] < k) midNext++;
            return Math.max(longestSubstringUtil(s, start, mid, k),
                    longestSubstringUtil(s, midNext, end, k));
        }
        return (end - start);
    }
}
```