# 480. Sliding Window Median

æœ¬é¢˜è¦æ±‚åœ¨æ•°ç»„ `nums` ä¸Šåšé•¿åº¦ä¸º `k` çš„æ»‘åŠ¨çª—å£ï¼Œè¿”å›æ¯ä¸ªçª—å£çš„ä¸­ä½æ•°ã€‚  

éš¾ç‚¹ï¼šçª—å£ç§»åŠ¨æ—¶ **åˆ é™¤ä»»æ„å…ƒç´ **ï¼ˆä¸æ˜¯å †é¡¶ï¼‰ï¼Œä½†å †ç»“æ„ä¸æ”¯æŒ O(log n) åˆ é™¤ä»»æ„ä½ç½® â†’ éœ€è¦ä½¿ç”¨â€œåŒå † + å»¶è¿Ÿåˆ é™¤ï¼ˆlazy deletionï¼‰â€ã€‚

é‡ç‚¹ï¼š æ¯ä¸€æ¬¡add / remvoe éƒ½è¦balance ä¸€æ¬¡

### ğŸ§  æ ¸å¿ƒæ€æƒ³ï¼ˆHigh-Level Overviewï¼‰
- ä½¿ç”¨ **æœ€å¤§å † leftHalf** å­˜å‚¨çª—å£è¾ƒå°çš„ä¸€åŠæ•°å­—ï¼ˆå †é¡¶æœ€å¤§ï¼‰
- ä½¿ç”¨ **æœ€å°å † rightHalf** å­˜å‚¨çª—å£è¾ƒå¤§çš„ä¸€åŠæ•°å­—ï¼ˆå †é¡¶æœ€å°ï¼‰
- ç¡®ä¿ï¼š 
    - leftHalfSize == rightHalfSize ï¼ˆçª—å£å¤§å°ä¸ºå¶æ•°ï¼‰
    - leftHalfSize == rightHalfSize + 1 ï¼ˆçª—å£å¤§å°ä¸ºå¥‡æ•°ï¼‰

- åˆ é™¤æ—§æ•°å­—æ—¶ä¸èƒ½ç›´æ¥ä»å †åˆ é™¤ â†’ é‡‡ç”¨ **å»¶è¿Ÿåˆ é™¤ï¼ˆdelayed mapï¼‰**  
å½“æŸä¸ªâ€œéœ€è¦åˆ é™¤â€çš„æ•°å­—å‡ºç°åœ¨å †é¡¶æ—¶ï¼Œå†çœŸæ­£ç§»é™¤ã€‚

#### ğŸ”§ æ­¥éª¤ä¸€ï¼šæ•°æ®ç»“æ„å‡†å¤‡
- `leftHalf`ï¼šæœ€å¤§å †ï¼ˆPriorityQueue reverseOrderï¼‰
- `rightHalf`ï¼šæœ€å°å †
- `delayed`ï¼šHashMapï¼Œè®°å½•â€œæ ‡è®°åˆ é™¤ä½†å°šæœªä»å †ç§»é™¤â€çš„æ•°å­—
- `leftHalfSize / rightHalfSize`ï¼šåˆ†åˆ«è®°å½•ä¸¤ä¸ªå †ä¸­â€œæœ‰æ•ˆæ•°å­—â€çš„æ•°é‡

> æ³¨æ„ï¼šå †æœ¬ä½“é‡Œçš„æ•°å­—æ•°é‡ä¸ä»£è¡¨æœ‰æ•ˆæ•°é‡  
> æœ‰æ•ˆæ•°é‡ = åŸæ•°é‡ - å»¶è¿Ÿåˆ é™¤çš„æ•°é‡


#### ğŸ”§ æ­¥éª¤äºŒï¼šåŠ å…¥ä¸€ä¸ªæ•°å­— addNum(num)
1. åˆ¤æ–­æ•°å­—æ”¾å…¥å“ªä¸ªå †
    - if (num <= leftHalf.peek()) â†’ åŠ å…¥å·¦å † else â†’ åŠ å…¥å³å †

2. å¯¹åº”å †çš„ size è®¡æ•° +1  
3. è°ƒç”¨ `balanceHeaps()` ä¿æŒä¸¤ä¸ªå †å¹³è¡¡

### ğŸ”§ æ­¥éª¤ä¸‰ï¼šåˆ é™¤ä¸€ä¸ªæ•°å­— removeNum(num)
å› ä¸ºåˆ é™¤ä»»æ„å…ƒç´ ä¸å¯èƒ½åœ¨ O(log n) é‡Œåšåˆ°ï¼Œæ‰€ä»¥ï¼š
1. åœ¨ delayed map ä¸­æ ‡è®°è¯¥æ•°å­—éœ€è¦è¢«åˆ é™¤ï¼š
2. åˆ¤æ–­è¯¥æ•°å­—å±äºå“ªä¸ªå †ï¼š
    - if (num <= leftHalf.peek()) â†’ å·¦å † size-- else â†’ å³å † size--
3. è‹¥è¯¥æ•°å­—æ°å¥½åœ¨å †é¡¶ â†’ ç«‹å³ prune é‚£ä¸ªå †ï¼ˆçœŸæ­£åˆ é™¤ï¼‰
4. è°ƒç”¨ `balanceHeaps()`

> ç”±äº prune æ¸…ç†äº†é¡¶ç«¯è¿‡æœŸå€¼ï¼ŒbalanceHeaps() æ—¶å †é¡¶ä¸€å®šæ˜¯æœ‰æ•ˆçš„ã€‚


### æ­¥éª¤å››ï¼šå¹³è¡¡ä¸¤ä¸ªå † balanceHeaps()
ç»´æŒå †æ•°é‡å…³ç³»ï¼š

###  æ­¥éª¤äº”ï¼šçœŸæ­£åˆ é™¤å †é¡¶çš„è¿‡æœŸå€¼ prune(heap)
ä¸æ–­ç§»é™¤ heap é¡¶éƒ¨çš„â€œå·²è¢« delayed æ ‡è®°çš„å…ƒç´ â€ï¼š

> prune çš„ä½œç”¨ï¼š  
> - balanceHeaps ä¼š poll() å †é¡¶  
> - poll åæš´éœ²å‡ºçš„æ–°å †é¡¶å¯èƒ½æ˜¯è¿‡æœŸå€¼  
> - prune è´Ÿè´£æ¸…ç†è¿™äº›â€œæ–°æš´éœ²çš„è¿‡æœŸå€¼â€

```java
class Solution {
    private PriorityQueue<Integer> leftHalf;
    private PriorityQueue<Integer> rightHalf;
    private Map<Integer, Integer> delayed;
    private int leftHalfSize;
    private int rightHalfSize;

    public double[] medianSlidingWindow(int[] nums, int k) {
        leftHalf = new PriorityQueue<>(Collections.reverseOrder());
        rightHalf = new PriorityQueue<>();
        delayed = new HashMap<>(); // <number to be deleted, times>
        int n = nums.length;
        double[] res = new double[n-k+1];
        leftHalfSize = 0;
        rightHalfSize = 0;

        // 1. åˆå§‹åŒ–å‰ k ä¸ªå…ƒç´ 
        for (int i = 0; i < k; i++) {
            addNum(nums[i]);
        } 

        res[0] = getMedian(k);

        // 2. æ»‘åŠ¨çª—å£
        for (int i = k; i < n; i++) {
            int newNum = nums[i]; // è¿›å…¥çª—å£çš„æ–°å…ƒç´ 
            int oldNum = nums[i-k]; // ç¦»å¼€çª—å£çš„æ—§å…ƒç´ 
             
            addNum(newNum);
            removeNum(oldNum);  // å»¶è¿Ÿåˆ é™¤

            res[i-k+1] = getMedian(k);
        }
        return res;
    }

    // æ’å…¥å…ƒç´ 
    private void addNum(int num) {
        if (leftHalf.isEmpty() || num <= leftHalf.peek()) {
            leftHalf.offer(num);
            leftHalfSize++;
        } else {
            rightHalf.offer(num);
            rightHalfSize++;
        }
        balanceHeaps(); // balance after adding 
    }

    // å¹³è¡¡ä¸¤ä¸ªå † (ä¿è¯ maxHeapSize >= minHeapSizeï¼Œä¸”å·®å€¼ä¸è¶…è¿‡ 1)
    private void balanceHeaps() {
        if (leftHalfSize > rightHalfSize + 1) {
            rightHalf.offer(leftHalf.poll());
            leftHalfSize--;
            rightHalfSize++;
            prune(leftHalf);
        } else if (leftHalfSize < rightHalfSize) {
            leftHalf.offer(rightHalf.poll());
            leftHalfSize++;
            rightHalfSize--;
            prune(rightHalf);
        }
    }
    
     // å»¶è¿Ÿåˆ é™¤å…ƒç´ 
    private void prune(PriorityQueue<Integer> heap) {
        while (!heap.isEmpty() && delayed.containsKey(heap.peek())) {
            int num = heap.peek();
            delayed.put(num, delayed.get(num)-1);
            if (delayed.get(num) == 0) delayed.remove(num);
            heap.poll();
        }
    }

    // æ¸…ç†å †é¡¶çš„è¿‡æœŸå…ƒç´ 
    private void removeNum(int num) {
        delayed.put(num, delayed.getOrDefault(num, 0)+1);
        
        if (num <= leftHalf.peek()) {
            leftHalfSize--;
            if (num == leftHalf.peek()) prune(leftHalf);
        } else {
            rightHalfSize--;
            if (num == rightHalf.peek()) prune(rightHalf);
        }
        balanceHeaps(); // balance after deleting
    }

    private double getMedian(int k) {
        if (k % 2 ==1) {
            return (double)leftHalf.peek();
        }
        return ((double)leftHalf.peek() + rightHalf.peek())/2.0;
    }
}

```