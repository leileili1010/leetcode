# 76. Minimum Window Substring

- 移动i or right pointer 是扩大窗口, 如果碰到target char, 需要对应value--, 表示加入到窗口，也表示需要找的数量减少。当value 变为0，count不能变了，因为所有target char都已经找到
- 移动左指针是缩小窗口，如果碰到target char, 需要对应value++, 表示加入到窗口，也表示需要找的数量增加。当value > 0, count--, 表示还有char需要找

```java
class Solution {
    public String minWindow(String s, String t) {
        // t contains duplicate chars, so we also need to count frequency of different characters
        // map的key代表这是一个target char, key对应的value代表我们需要找到多少个这样的char
        HashMap<Character, Integer> map = new HashMap<>();
         for (char c: t.toCharArray()) {
            map.put(c, map.getOrDefault(c, 0)+1);
        }
        
        // two pointers, left and i is the right iterator
        int left = 0, count = 0, minStart = 0, minLen = Integer.MAX_VALUE;
        for (int i = 0; i < s.length(); i++) {
            char cur = s.charAt(i);
            if (map.containsKey(cur)) {
                if (map.get(cur) > 0) count++; // 找到了target char
                map.put(cur, map.get(cur)-1); // 找到一个target char，我们就减少一个需要找的数量  
            }

            while (count == t.length()) { //此时在一段substring中找到了所有target chars, map中的value都为0，这不代表这是最短substring （只要count == t.length()，窗口就是valid
                // 先更新minLen, 在解决最短的问题
                if (i - left + 1 < minLen) {
                    minStart = left;
                    minLen = i - left + 1;
                }

                // 试图在当下这个已经合格的情况下找最短, 这一段比较难理解
                char c = s.charAt(left);
                if (map.containsKey(c)) {
                    map.put(c, map.get(c)+1); // 当character的value+1的时候表示我们把某个target char移除窗口
                    if (map.get(c) > 0) count--; // 当map中某个char的value > 0, 表示我们又需要开始找这个char了，当前窗口不valid了
                }
                
                left++;
            }
        }

        if (minLen == Integer.MAX_VALUE) return "";
        return s.substring(minStart, minStart+minLen);
    }
}

```

## Approach 2

- **解题思路**  
  - 分清楚什么时候 **进入 window**，什么时候 **出 window**。  
  - **进入 window**：右指针向右移动，grab 一个新的字符，把它放入到 `map` 中，表示进入窗口。  
  - **shrink window**：当窗口中已经包含了所有的字母时（即当前 substring 覆盖了 T），就开始收缩左边的窗口。  
  - shrink 的过程是：**只要 substring 仍然 valid，就继续 shrink 左边**。  



- **关键点 1: while 条件是 valid**  
  - 一般滑动窗口的 `while` 条件是 **invalid → shrink**。  
  - 本题的 `while` 条件是 **valid → shrink**。  
  - 在 shrink 的过程中，更新当前最优解。  



- **关键点 2: substring 的记录方式**  
  - 使用 `minStart` 和 `minLen` 来保存结果。  
  - `minLen = right - left` → 表示窗口长度。  
  - `minStart = left` → 表示窗口起点。  
  - 在 `while` 循环里更新 `(minStart, minLen)`。  
  - 最后根据 `(minStart, minLen)` 返回 substring。  



- **关键点 3: count 的含义**  
  - `count` 表示满足要求的 **字母种类数**，而不是字母总数。  
  - 例如：`t = "aabc"`，在 `map` 里面的 key 是 `a, b, c` → count 最大值是 3。  
  - 所以 `count` 表示的是不同字符的数量，而不是所有字符的个数。  



- **关键点 4: HashMap 的比较**  
  - `map` 和 `window` 都是 `HashMap<Character, Integer>`。  
  - 比较时必须用 `.equals`，不能用 `==`。  
  - 示例：  
    ```java
    if (window.get(c).equals(map.get(c))) {
        count++;
    }
    ```

- time: O(M+N)
- Space: O(M+N)

```java
class Solution {
    public String minWindow(String s, String t) {
        if (t.length() > s.length()) return ""; 
        Map<Character, Integer> map = new HashMap<>();
        Map<Character, Integer> window = new HashMap<>();

        for (char c: t.toCharArray()) {
            map.put(c, map.getOrDefault(c, 0)+1);
        }

        int left = 0, validCount = 0, minStart = 0, minLen = Integer.MAX_VALUE;
        for (int i = 0; i < s.length(); i++) {
            // char enters window, update window and validCount
            char cur = s.charAt(i);
            if (map.containsKey(cur)) {
                window.put(cur, window.getOrDefault(cur, 0)+1);
                if (window.get(cur).equals(map.get(cur))) validCount++; // must be equal not >=
            }   
            
            // if not valid, keep expanding window
            // if valid (validCount == map.size(), shrink window and update minLen and minStart)
            while (validCount == map.size()) {
                // while loop means valid, so we update minLen and minStart inside while loop. For other sliding window problems, while loop means not valid, so we update res (e.g maxLen) outside while loop
                if (i-left+1 < minLen) {
                    minLen = i - left +1;
                    minStart = left;
                }
                
                char c = s.charAt(left);
                if (window.containsKey(c)) {
                    window.put(c, window.get(c)-1);
                    if (window.get(c) < map.get(c)) validCount--;
                }
                left++;
            }
        }
       
        return minLen == Integer.MAX_VALUE? "": s.substring(minStart, minStart+minLen); 
    }
}
```

- uses .equals() instead of == — and the reason is because it's comparing Integer objects, not primitive int values.
- window.get(cur) and map.get(cur) return Integer objects
- use == will exceed time limit

- 这种解法用map比较慢，用arry更快

```java
// 比较推荐这种写法 非常好理解 也好写 比hashMap快
class Solution {
    public String minWindow(String s, String t) {
        int[] cntS = new int[128];
        int[] cntT = new int[128];
        int need = 0;

        for (char c: t.toCharArray()) {
            if (cntT[c] == 0) need++;
            cntT[c]++;
        }

        int left = 0, hava = 0, minStart = 0, minLen = Integer.MAX_VALUE;
        
        char[] arr = s.toCharArray();
        
        for (int i = 0; i < arr.length; i++) {
            char curr = arr[i];
            if (cntT[curr] > 0) {
                cntS[curr]++;
                if (cntS[curr] == cntT[curr]) hava++;
            }    

            while (hava == need) {
                if (i-left+1 < minLen) {
                    minStart = left;
                    minLen = i-left+1;
                }

                char lc = arr[left];
               
                if (cntT[lc] > 0) {
                    cntS[lc]--;
                    if (cntS[lc] < cntT[lc]) hava--;
                }  

                left++;
            }
        }
        return minLen == Integer.MAX_VALUE? "": s.substring(minStart, minStart+minLen);
    }
}
```