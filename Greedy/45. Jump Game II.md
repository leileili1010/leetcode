# 45. Jump Game II

这一跳我不需要现在决定跳到哪个点, 只关心这一跳结束后，我最远能覆盖到哪里
- i: 我正在查看哪些位置是**可能的起跳点**
- curRight: 当前这一跳，能覆盖到的最远范围
- nextRight: 下一跳，能覆盖到的最远范围

e.g [2, 3, 1, 1 4] 
- 站在index 0, 我可以跳到index 0, index 1, or index 2
    - curRight: 计算出当前这一跳能够到达的最远点, 也就是index 2 
- 遍历继续：从 0，1，2， here, 当我们到达2之前就已经扫过 index 2 之前，所有可能起点能够到达的最远处, 一边遍历一边更新nextRight，下一跳可以是0， 1， 2 中任何一个
    - nextRight = max(nextRight, i + nums[i]) = 2
    - 如果假设从index 1 跳能到达比index 2更远的地方，nextRight就会被更新，所以我们不会错过更好的选择
- 当 i < curRight 时，我们在收集信息
    - 再到达curRight之前，从哪个点起跳，下一跳能跳得最远
    - i == curRight 表示：当前这一跳 所能覆盖的所有位置，已经被我全部检查完了。所以：我必须跳一次（steps++）

总结： 我先用一跳，看我最多能到哪；在这个范围内，我把所有可能的下一跳起点都看一遍；当这些点都看完了，我就必须再跳一次。

为什么是i < nums.length -1 而不是i < nums.length？ 
    - 站在最后一个位置，不需要再跳了， 所以我们不应该在最后一个 index 上触发res++

```java
class Solution {
    public int jump(int[] nums) {
        int ans = 0;
        int curRight = 0; // 已建造的桥的右端点
        int nextRight = 0; // 下一座桥的右端点的最大值
        for (int i = 0; i < nums.length - 1; i++) { 
            // 遍历的过程中，记录下一座桥的最远点
            nextRight = Math.max(nextRight, i + nums[i]);
            if (i == curRight) { // 无路可走，必须建桥
                curRight = nextRight; // 建桥后，最远可以到达 next_right
                ans++;
                // if (curRight >= nums.length-1) return ans; 可以加上这几句更快
            }
        }
        return ans;
    }
}
```