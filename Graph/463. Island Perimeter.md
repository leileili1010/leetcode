# 463. Island Perimeter

## Approach 1 非常慢的方法
- time: O(m * n) 
- space: O(1)

- 我们会遍历整个二维网格中的每一个格子。

    - 如果当前格子是 0，说明是水域，直接跳过。
    - 如果当前格子是 1，说明是陆地，那么我们先假设它的周长贡献是 4。
    - 接着，我们检查它的四个方向（上、下、左、右）。
    - 如果某个方向上也有陆地（即相邻格子为 1），说明这两块陆地相连，共用了一条边，于是周长要减去 1。
    - 最终，我们把每个陆地格子的贡献累加起来，得到整座岛屿的总周长。

```java
class Solution {
    public int islandPerimeter(int[][] grid) {
        int rows = grid.length;
        int cols = grid[0].length;
        int res = 0;
        int[][] steps = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                // only start looping 4 directions if we find 1, skip 0
                if (grid[i][j] == 1) {
                    res += 4;
                    
                    for (int[] step: steps) {
                        int x = i + step[0];
                        int y = j + step[1];
                        if (isValid(x, y, grid)) res--;
                    }
                }
            }
        }
        return res;
    }    
                    
    private boolean isValid(int x, int y, int[][] grid) {
        return x >= 0 && x < grid.length && y >= 0 && y < grid[0].length && grid[x][y] == 1;
    }
}
```

## Approach 2 比较快（推荐, 但是比较难想）
- time: O(m * n) 
- space: O(1)

### Intuition
- Each land cell (1) has 4 sides.
- Whenever two land cells are adjacent, they share one edge, so that shared edge shouldn’t count twice.
- So the logic is:
    - Start with 4 sides for every land cell.
    - Subtract 2 for each shared edge with a neighbor that’s already counted.
    - we could only check left and right because we loop through left to right, up to bottom

```java
953. Verifying an Alienclass Solution {
    public int islandPerimeter(int[][] grid) {
        int rows = grid.length;
        int cols = grid[0].length;
        
        int result = 0;
        for (int r = 0; r < rows; r++) {
            for (int c = 0; c < cols; c++) {
                if (grid[r][c] == 1) {
                    result += 4;
                    
                    // only check the upside
                    if (r > 0 && grid[r-1][c] == 1) {
                        result -= 2;
                    }

                    // only check the left side
                    if (c > 0 && grid[r][c-1] == 1) {
                        result -= 2;
                    }
                }
            }
        }
        
        return result;
    }
}
```