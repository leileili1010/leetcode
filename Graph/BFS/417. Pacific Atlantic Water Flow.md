# 417. Pacific Atlantic Water Flow

## Approah
- 核心思路不是从网格的中间开始找，而是从边界出发。
    - 我们先遍历四个边界上的所有格子，并从这些边界格子进行 BFS，寻找哪些格子能够流向海洋。
    - 对于太平洋和大西洋，我们分别执行 BFS，并用两个 visited 集合分别记录能到达太平洋和能到达大西洋的格子。
    - 最后，我们再遍历整个网格，找出同时能到达两边的格子，把它们加入结果即可。

```java
class Solution {
    int cols;
    int rows;
    int[][] steps = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

    public List<List<Integer>> pacificAtlantic(int[][] heights) {
        rows = heights.length;
        cols = heights[0].length;
        boolean[][] pacific = new boolean[rows][cols];
        boolean[][] atlantic = new boolean[rows][cols];
        List<List<Integer>> res = new ArrayList<>();

        for (int i = 0; i < rows; i++) {
            bfs(heights, i, 0, pacific);
            bfs(heights, i, cols-1, atlantic);
        }

        for (int j = 0; j < cols; j++) {
            bfs(heights, 0, j, pacific);
            bfs(heights, rows-1, j, atlantic);
        }

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (pacific[i][j] && atlantic[i][j]) {
                    res.add(new ArrayList<>(Arrays.asList(i, j)));
                }
            }
        }
        return res;
    }

    private void bfs(int[][] heights, int i, int j, boolean[][] visited) {
        Deque<int[]> que = new ArrayDeque<>();
        que.offer(new int[]{i, j});
        visited[i][j] = true;

        while (!que.isEmpty()) {
            int[] cur = que.poll();
            int row = cur[0];
            int col = cur[1];

            for (int[] step: steps) {
                int newRow = row + step[0];
                int newCol = col + step[1];
                if (isValid(newRow, newCol, visited) && heights[newRow][newCol] >= heights[row][col]) {
                    que.offer(new int[] {newRow, newCol});
                    visited[newRow][newCol] = true;
                }
            }
        }
    } 

    private boolean isValid(int i, int j, boolean[][] visited) {
        return i >= 0 && i < rows && j >= 0 && j < cols && !visited[i][j];
    }
}
```