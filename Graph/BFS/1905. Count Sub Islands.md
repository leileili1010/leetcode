# 1905. Count Sub Islands

## Approach 1 - BFS (推荐 更容易写)

这道题本质上跟经典的 **Number of Islands（岛屿数量）** 是一样的套路：

- 你仍然是在 **grid2** 里面遍历岛屿  
- 每找到一个 `1`（且未访问过），就启动一次 **BFS 整个岛屿**
- BFS 会把这一整块岛的所有 cell 都跑完（标准岛屿遍历模板）

不同之处只有一个：

- **在 BFS grid2 的同时，还需要用 grid1 去检查这个岛是否是 sub-island。**  
    - 即 grid2 的岛屿必须被 grid1 完全覆盖。

    - **如果在 BFS 中遇到任何一个 cell：**  
    `grid2[r][c] == 1` 但是 `grid1[r][c] == 0` , 那么这个岛屿立刻被判定为 **not sub island**。

    - 因此 BFS 返回的不是 void，boolean
- time: O(rows * cols);
- space: O(rows * cols);

```java
class Solution {
    int rows;
    int cols;
    int[][] dirs = {{1,0}, {-1,0}, {0,1}, {0,-1}};

    public int countSubIslands(int[][] grid1, int[][] grid2) {
        rows = grid2.length;
        cols = grid2[0].length;

        boolean[][] visited = new boolean[rows][cols];
        int count = 0;

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {

                if (grid2[i][j] == 1 && !visited[i][j]) {
                    boolean isSub = bfs(i, j, grid2, grid1, visited);
                    if (isSub) count++;
                }
            }
        }
        return count;
    }

    private boolean bfs(int row, int col, int[][] grid2, int[][] grid1, boolean[][] visited) {
        Deque<int[]> que = new ArrayDeque<>();
        que.offer(new int[]{row, col});
        visited[row][col] = true;

        boolean isSubisland = true;

        while (!que.isEmpty()) {
            int[] cur = que.poll();
            int r = cur[0];
            int c = cur[1];

            // 核心检查：grid1 对应位置必须为 1
            if (grid1[r][c] != 1) {
                isSubisland = false;
            }

            // 扩散 BFS
            for (int[] d : dirs) {
                int nr = r + d[0];
                int nc = c + d[1];

                if (isValid(nr, nc, grid2, visited)) {
                    visited[nr][nc] = true;
                    que.offer(new int[]{nr, nc});
                }
            }
        }

        return isSubisland;
    }

    private boolean isValid(int row, int col, int[][] grid, boolean[][] visited) {
        return row >= 0 && row < rows &&
               col >= 0 && col < cols &&
               grid[row][col] == 1 &&
               !visited[row][col];
    }
}
```