# 1905. Count Sub Islands

## Approach 1 - BFS

```java
class Solution {
    int rows;
    int cols;
    int[][] dirs = {{1,0}, {-1,0}, {0,1}, {0,-1}};

    public int countSubIslands(int[][] grid1, int[][] grid2) {
        rows = grid2.length;
        cols = grid2[0].length;

        boolean[][] visited = new boolean[rows][cols];
        int count = 0;

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {

                if (grid2[i][j] == 1 && !visited[i][j]) {
                    boolean isSub = bfs(i, j, grid2, grid1, visited);
                    if (isSub) count++;
                }
            }
        }
        return count;
    }

    private boolean bfs(int row, int col, int[][] grid2, int[][] grid1, boolean[][] visited) {
        Deque<int[]> que = new ArrayDeque<>();
        que.offer(new int[]{row, col});
        visited[row][col] = true;

        boolean isSubisland = true;

        while (!que.isEmpty()) {
            int[] cur = que.poll();
            int r = cur[0];
            int c = cur[1];

            // 核心检查：grid1 对应位置必须为 1
            if (grid1[r][c] != 1) {
                isSubisland = false;
            }

            // 扩散 BFS
            for (int[] d : dirs) {
                int nr = r + d[0];
                int nc = c + d[1];

                if (isValid(nr, nc, grid2, visited)) {
                    visited[nr][nc] = true;
                    que.offer(new int[]{nr, nc});
                }
            }
        }

        return isSubisland;
    }

    private boolean isValid(int row, int col, int[][] grid, boolean[][] visited) {
        return row >= 0 && row < rows &&
               col >= 0 && col < cols &&
               grid[row][col] == 1 &&
               !visited[row][col];
    }
}
```