# 1650. Lowest Common Ancestor of a Binary Tree III

## Approach 1 - set

```java
class Solution {
    public Node lowestCommonAncestor(Node p, Node q) {
        Set<Node> set = new HashSet<>();
        Node curr = p;

        while (curr != null) {
            set.add(curr);
            curr = curr.parent;
        }

        curr = q;
        while (curr != null) {
            if (set.contains(curr)) return curr;
            curr = curr.parent;
        }
        
        return null;
    }   
}
```

## Approach 2 - list
- list 一定要从后往前比， 第一个分叉路之前的一个node就是LCA

```java
class Solution {
    public Node lowestCommonAncestor(Node p, Node q) {
        List<Node> parents1 = findParents(p);
        List<Node> parents2 = findParents(q);

        int i = parents1.size()-1, j = parents2.size()-1;
        Node res = null;
        while (i >= 0 && j >= 0) {
            if (parents1.get(i).val == parents2.get(j).val) res = parents2.get(j);
            else break; 

            i--;
            j--;
        }

        return res;
    }

    private List<Node> findParents(Node node) {
        Node curr = node;
        List<Node> res = new ArrayList<>();

        while (curr != null) {
            res.add(curr);
            curr = curr.parent;
        }
        return res;
    }
}

```