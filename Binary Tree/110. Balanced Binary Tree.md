# 110. Balanced Binary Tree

## Approach 1 - divide and conquer (不推荐， 很慢)

```java
class Solution {
    private int height(TreeNode root) {
        // An empty tree has height -1
        if (root == null) {
            return 0;
        }
        return 1 + Math.max(height(root.left), height(root.right));
    }

    public boolean isBalanced(TreeNode root) {
        // An empty tree satisfies the definition of a balanced tree
        if (root == null) {
            return true;
        }

        return (
            Math.abs(height(root.left) - height(root.right)) <= 1 &&
            isBalanced(root.left) &&
            isBalanced(root.right)
        );
    }
}
```

## Approach 2 - postorder dfs (推荐)

- 时间复杂度：O(n)，其中 n 为二叉树的节点个数。
- 空间复杂度：O(n)。最坏情况下，二叉树退化成一条链，递归需要 O(n) 的栈空间。

### 写法一

- 不平衡代表左右子树高度之差 > 1
- 知道怎么求高度，相减即可判断
- 思考：如果在递归过程中已经发现了某一边不平衡，应该返回什么？
    - 返回的高度都是正数，所以可以用负数，比如-1来代表不平衡
    - 如果某一处出现-1， -1 会一直被返回到最顶层，使得最后的答案/返回值就是-1

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return getHeight(root) != -1;
    }

    private int getHeight(TreeNode node) {
        if (node == null) {
            return 0;
        }
        int leftH = getHeight(node.left);
        int rightH = getHeight(node.right);
        if (leftH == -1 || rightH == -1 || Math.abs(leftH - rightH) > 1) {
            return -1;
        }
        return Math.max(leftH, rightH) + 1;
    }
}
```

### 写法二

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return getHeight(root) != -1;
    }

    private int getHeight(TreeNode node) {
        if (node == null) {
            return 0;
        }
        int leftH = getHeight(node.left);
        if (leftH == -1) {
            return -1; // 提前退出，不再递归
        }
        int rightH = getHeight(node.right);
        if (rightH == -1 || Math.abs(leftH - rightH) > 1) {
            return -1;
        }
        return Math.max(leftH, rightH) + 1;
    }
}
```