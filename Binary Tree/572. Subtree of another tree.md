# 572. Subtree of another tree

## Approach 1 - preorder dfs (暴力比较)

这道题的难点或者说很不容易先到的是大reversion里面套着另外一种recursion. 
- 思路是，先比较树的整体和subRoot是不是一样，不是的话再比较树的右子树 || 树的左子树，recursively repeat this process
- How to know if the two trees are the same? - using another helper function isSameTree(), which is also a recursive function

```java
class Solution {
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {
        if (subRoot == null) return true;
        if (root == null) return false;

        return isSameTree(root, subRoot) || isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);
    }

    private boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) return true;
        if (p == null || q == null) return false;
        if (p.val != q.val) return false;

        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
}
```

 - time: O(MN). For every N node in the tree, we check if the tree rooted at node is identical to subRoot. This check takes O(M) time, where M is the number of nodes in subRoot. Hence, the overall time complexity is O(MN)
 - space: O(n)。无论 m 大于 n 还是小于 n，递归深度都不会超过 O(n)，所需的栈空间为 O(n)

 ## Approach 2 - 只在高度相同时匹配 （最优）

1. 初始化
    - 设 subRoot 的高度为 hs
    - 设 node 为 root 中的节点。我们可以在匹配之前，先判断 node 的高度是否等于 hs， 只有在相等时才做匹配。
    - 如果一个节点的高度都不等于 hs，它 绝不可能 与 subRoot 完全相同。这是非常强力的 剪枝（pruning）技巧
2. 递归获得左右子树的 Result
3. 如果任何一侧 found = true，即刻返回（剪枝）
4. 计算当前节点高度
5. 若高度等于 subRoot 高度，则尝试 isSameTree
6. 返回新 Result

 ```java
class Result {
    int height;
    boolean found;

    Result(int height, boolean found) {
        this.height = height;
        this.found = found;
    }
}
class Solution {
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {
        int hs = getHeight(subRoot);
        return dfs(root, subRoot, hs).found;
    }

    // 代码逻辑同 104. 二叉树的最大深度
    private int getHeight(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftH = getHeight(root.left);
        int rightH = getHeight(root.right);
        return Math.max(leftH, rightH) + 1;
    }

    // 100. 相同的树
    private boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null || q == null) {
            return p == q; // 必须都是 null
        }
        return p.val == q.val &&
               isSameTree(p.left, q.left) &&
               isSameTree(p.right, q.right);
    }

    // 返回 node 的高度，以及是否找到了 subRoot
    private Result dfs(TreeNode node, TreeNode subRoot, int hs) {
        if (node == null) {
            return new Result(0, false);
        }
        
        Result left = dfs(node.left, subRoot, hs);
        Result right = dfs(node.right, subRoot, hs);
        
        if (left.found || right.found) {
            return new Result(0, true);
        }
        
        int nodeH = Math.max(left.height, right.height) + 1;

        // 最关键的一步： 只在高度完全相等的节点上做 isSameTree。其他节点自动跳过，节省大量时间。
        return new Result(nodeH, nodeH == hs && isSameTree(node, subRoot));
    }
}
 ```

 - time: 
    - worset: O(NM)
    - avarage: O(N + kM) ==> O(N)
 - space: O(N)
