# 1448. Count Good Nodes in Binary Tree

## Approach 1 - 分治法

![alt text](image-6.png)

[tutorial](https://www.google.com/search?q=1448.+count+good+nodes+in+binary+tree&rlz=1C1OPNX_enUS1086US1086&oq=1448.+Count+Good+Nodes+in+Binary+Tree&gs_lcrp=EgZjaHJvbWUqBwgAEAAYgAQyBwgAEAAYgAQyDQgBEAAYhgMYgAQYigUyDQgCEAAYhgMYgAQYigUyDQgDEAAYhgMYgAQYigUyDQgEEAAYhgMYgAQYigUyCggFEAAYogQYiQUyCggGEAAYgAQYogQyBggHEEUYPKgCALACAA&sourceid=chrome&ie=UTF-8#fpstate=ive&vld=cid:6904b556,vid:7cp5imvDzl4,st:0)

- using preorder DFS， 因为每一条路径都要经过各个根节点，我们需要比较根节点的值和max的值，这样才能和后面的节点进行比较

```java
class Solution {
    public int goodNodes(TreeNode root) {
        return dfs(root, Integer.MIN_VALUE); 
    }

    private int dfs(TreeNode root, int mx) { // return => 有多少符合要求的nodes
        if (root == null)
            return 0; 

        int res = root.val >= mx? 1: 0;
        if (res == 1) mx = root.val;
        res += dfs(root.left, mx);
        res += dfs(root.right, mx);
        return res;
    }
}
```
- 时间复杂度：O(n)，其中 n 为二叉树的节点个数。每个节点都会递归恰好一次。
- 空间复杂度：O(H)。最坏情况下，二叉树是一条链，递归需要 O(n) 的栈空间。

## Approach 2 - 遍历法 (preorder dfs)

```java
class Solution {
    private int res = 0;
    
    public int goodNodes(TreeNode root) {
        dfs(root, Integer.MIN_VALUE);
        return res;
    }

    private void dfs(TreeNode node, int max) {
        if (node == null) return;

        if (node.val >= max) {
            res++;
            max = node.val;
        }

        dfs(node.left, max);
        dfs(node.right, max);
    }
}
```
- time: O(N)
- space: O(H)