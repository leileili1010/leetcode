# 414. Third Maximum Number

## Approach 1 - Three buckets 
- 在解这道题时要特别注意初始化的问题。我们不能把三个 bucket（min、mid、max）的初始值直接定义为 null，因为对于小写的 int 或 long 这样的基本类型来说，这是不允许的；而大写的 Integer 或 Long 虽然可以设置为 null，但这样做会引入空指针判断，使用起来并不方便。

- 另外，我们也不能把初始值直接设为 int 的最小值（Integer.MIN_VALUE）。原因是：题目中的数据范围本身就可能包含整型的最小值或最大值。如果某个 bucket 恰好遇到这个值，我们将无法判断它到底是初始化的占位值，还是题目中实际给出的数字。

- 为了解决这个问题，我们使用大写的 Long 类型来定义 bucket，并把它们初始化为 Long.MIN_VALUE。这样一来，long 的取值范围（-2^63 到 2^63-1）比 int 的范围（-2^31 到 2^31-1）大得多，可以保证我们选择的初始化值不会与题目输入冲突。

- 后续步骤就是：
    - 先进行去重
    - 然后依次比较更新最大值、中间值和最小值。
    - 最后在输出结果时，因为返回值需要是 int，我们只需要在前面强制转换 (int) 即可。

```java
class Solution {
    public int thirdMax(int[] nums) {
        long min = Long.MIN_VALUE;
        long mid = Long.MIN_VALUE;
        long max = Long.MIN_VALUE;

        for (int num: nums ) {
            if (num == min || num == mid || num == max) continue;

            if (num > max) {
                min = mid;
                mid = max;
                max = num;
            } else if (num > mid) {
                min = mid;
                mid = num;
            } else if (num > min) {
                min = num;
            }
        }

        return min == Long.MIN_VALUE? (int)max: (int)min;
    }
}
```
time: O(n);

## Approach 3 - TreeSet
- 数据结构
    - TreeSet<E> 基于 红黑树（自平衡二叉搜索树）。
    - 有序：元素按 自然顺序（Comparable）或你传入的 Comparator 排序；迭代时就是升序
    - 去重：是 Set，不允许重复；“重复”的判断依据是 比较结果为 0（compareTo/Comparator），不看 equals
    - Null：TreeSet<Integer> 不允许 null（排序比较会 NPE）。

- 时间复杂度：
    - 插入/删除/查找 O(log n)。（对比 HashSet 平均 O(1)，但无序）
    - 拿最小值 first() / 最大值 last() → O(log n) （但实际上因为红黑树有指针直接指向最左/最右节点，所以几乎可以看成 O(1) 常数时间）
    - 弹出最小值 pollFirst() / 弹出最大值 pollLast() → O(log n) （因为删除节点需要重新平衡）

- Operation
    - first() / last()：最小/最大
    - pollFirst() / pollLast()：弹出最小/最大
    - higher(x) / lower(x)：严格大于/小于 x 的最近元素, 没有符合条件的返回null
    - ceiling(x) / floor(x)：≥ x / ≤ x 的最近元素, 没有符合条件的返回null

- 和其他 Set 的区别
    - HashSet：无序，增删查均摊 O(1)，适合只要“去重”不关心顺序的场景。
    - LinkedHashSet：按插入顺序迭代（或访问顺序），均摊 O(1)。
    - TreeSet：排序 + 导航能力（first/last/higher/lower…），O(log n)

```java

```