# 414. Third Maximum Number

## Approach 1 - Three buckets 
- 在解这道题时要特别注意初始化的问题。我们不能把三个 bucket（min、mid、max）的初始值直接定义为 null，因为对于小写的 int 或 long 这样的基本类型来说，这是不允许的；而大写的 Integer 或 Long 虽然可以设置为 null，但这样做会引入空指针判断，使用起来并不方便。

- 另外，我们也不能把初始值直接设为 int 的最小值（Integer.MIN_VALUE）。原因是：题目中的数据范围本身就可能包含整型的最小值或最大值。如果某个 bucket 恰好遇到这个值，我们将无法判断它到底是初始化的占位值，还是题目中实际给出的数字。

- 为了解决这个问题，我们使用大写的 Long 类型来定义 bucket，并把它们初始化为 Long.MIN_VALUE。这样一来，long 的取值范围（-2^63 到 2^63-1）比 int 的范围（-2^31 到 2^31-1）大得多，可以保证我们选择的初始化值不会与题目输入冲突。

- 后续步骤就是：
    - 先进行去重
    - 然后依次比较更新最大值、中间值和最小值。
    - 最后在输出结果时，因为返回值需要是 int，我们只需要在前面强制转换 (int) 即可。

```java
class Solution {
    public int thirdMax(int[] nums) {
        long min = Long.MIN_VALUE;
        long mid = Long.MIN_VALUE;
        long max = Long.MIN_VALUE;

        for (int num: nums ) {
            if (num == min || num == mid || num == max) continue;

            if (num > max) {
                min = mid;
                mid = max;
                max = num;
            } else if (num > mid) {
                min = mid;
                mid = num;
            } else if (num > min) {
                min = num;
            }
        }

        return min == Long.MIN_VALUE? (int)max: (int)min;
    }
}
```
time: O(n);

## Approach 3 - TreeSet


```java

```