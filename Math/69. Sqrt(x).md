# Sqrt(x)

## Approach: binary search
这道题其实求的是 mid * mid <= x的最后一个数

### 正确写法
- right边界的确认，比x/2大的不可能成为x的平方根
- 每次判断 mid^2 <= x 时，mid 可能是一个合法解（平方根的下界），但是不一定是最终解（可能还有更大的符合条件的）。
    - 如果我们只在等于的时候直接返回 mid，那大多数时候（当 x 不是完全平方数时）就走不到 return mid，最终会直接退出循环。这样我们需要有一个变量来记录最后一次符合 mid^2 <= x 的那个 mid

```java
class Solution {
    public int mySqrt(int x) {
        if (x < 2) return x;
        int left = 1, right = x/2;
        int ans = 1;

        while (left <= right) {
            int mid = left + (right-left)/2;
            if (mid <= x/mid) {
                left = mid + 1;
                ans = mid;
            } else {
                right = mid - 1;
            }
        }
        return ans;   
    }
}

// 另一种比较好理解的写法 但是要注意边界
class Solution {
    public int mySqrt(int x) {
        if (x <= 1) return x;

        int left = 0, right = x / 2;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            long product = (long) mid * mid;  // 用 long 防止溢出

            
            if (product <= x) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return right;  // 最后 right 落在 floor(sqrt(x))
    }
}
```

### 错误写法
- 很好理解确实错误的写法
- 0 <= x <= 2^31 - 1, mid * mid会导致int overflow

```java
class Solution {
    public int mySqrt(int x) {
        if(x < 2) return x;
        int left = 1, right = x/2;
        int ans = 1;

        while (left <= right) {
            int mid = left + (right-left)/2;
            if (mid * mid < x) {
                left = mid + 1;
                ans = mid;
            } else if (mid * mid > x) {
                right = mid-1;
            } else {
                return mid;
            }
        }
        return ans;
    }
}
```