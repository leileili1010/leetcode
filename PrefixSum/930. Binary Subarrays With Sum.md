# 930. Binary Subarrays With Sum

## Approach 1 - HashMap + prefixSum
- Time: O(N)
- Space: O(N)

```java
class Solution {
    public int numSubarraysWithSum(int[] nums, int goal) {
        Map<Integer, Integer> map = new HashMap<>(); // <sum, count>
        map.put(0,1);
        int sum = 0, res = 0;

        for (int num: nums) {
            sum += num; // sum = 2 + 1 = 3
            if (map.containsKey(sum-goal)) { // sum-goal = 3 - 2 = 1
                res += map.get(sum-goal); // res = 2+2 = 4
            }
            map.put(sum, map.getOrDefault(sum, 0)+1);
        }
        return res; // 4
    }
}
```
## Approach 2 - two pointers (更优化)

- Time: O(N)
- Space: O(1)

### 思路
- Sliding window 用于解决 <= k 的问题
    - atMost(k) = 子数组和 ≤ k 的子数组个数
    - atMost(goal) 包含所有 sum ≤ goal 的子数组
    - atMost(goal-1) 包含所有 sum ≤ goal-1 的子数组
    - exactly(goal) = atMost(goal) - atMost(goal-1)
    - res += (right - left + 1) 是所有结尾 == k 的subarray的数量

```java
class Solution {
    public int numSubarraysWithSum(int[] nums, int goal) {
        return atMost(nums, goal) - atMost(nums, goal-1);
    }

    private int atMost(int[] nums, int k) {
        if (k < 0) return 0;

        int left = 0, res = 0, sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];

            while (sum > k) {
                sum -= nums[left++];
            }
            res += i - left + 1;
        }
        return res;
    }
}
```