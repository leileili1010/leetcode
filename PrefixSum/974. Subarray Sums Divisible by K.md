# 974. Subarray Sums Divisible by K

## Approach - 前缀和 + 同余（mod）
- 理论：r如果 prefix[j] % k == prefix[i] % k，则 prefix[j] - prefix[i] = subarray sum 可以被 k整除
- 初始化： map 存remainder 和 remainder count
- 遍历数组，计算前缀和 prefix sum， 每次算出 sum % k 的值（remainder）
    - 如果map里面有 remainder，则发现可以sum可以被k整除的subarray(s)
    - 在map里面更新remainder count;
    - 注意这里因为有正有负，比如 k = 5, prefix[1] = 11, 余数1， reprefix[5] = -9， 余数-4，我们要把-4也转换成1，因为-9-11 = -20 可以被5整除，但因为是负数所以余数不一样，我们要转换

```java
class Solution {
    public int subarraysDivByK(int[] nums, int k) {
        Map<Integer, Integer> remainderCount = new HashMap<>(); // <reminder, count>
        remainderCount.put(0, 1); // remainder能被k整除的count, 0 % k = 0, so remainder = 0, count = 1
        int sum = 0, res = 0;

        for (int num: nums) {
            sum += num;
            int remainder = ((sum % k) + k) % k;

            if (remainderCount.containsKey(remainder)) {
                res += remainderCount.get(remainder);
            }
            remainderCount.put(remainder, remainderCount.getOrDefault(remainder, 0)+1);
        }
        return res;
    }
}
```