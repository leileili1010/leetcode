# 2483. Minimum Penalty for a Shop

```java
class Solution {
    public int bestClosingTime(String customers) {
        int n = customers.length();
        int prefixSum = 0;

        int max = 0, res = 0;
        for (int i = 0; i < n; i++) {
            prefixSum = prefixSum + (customers.charAt(i) == 'Y'? 1: -1);
            if (prefixSum > max) {
                max = prefixSum;
                res = i+1;
            }
        }
        return res;
    }
}
```

同样的方法，不同写法：

- 把 customers 分成两段，第一段计算 N 的个数 preN，第二段计算 Y 的个数 sufY。
- 计算 preN+sufY 的最小值对应的最小分割位置 i，其中 [0,i−1] 是第一段，[i,n−1] 是第二段。
- 先假设所有字母都在第二段，统计 customers 中 Y 的个数 sufY
- 想象一根分割线在从左到右移动，customers[i] 原来在第二段，现在在第一段。如果 customers[i]=N，那么把 preN 加一（preN 初始值为 0），否则把 sufY 减一
-  preN(-1) + sufY(+1) 最小时对应的分割位置
- 所以我们一开始就假定totalPenatly = number of Y, 然后在遍历过程中计算totalPenlity相对变化的最小值

```java
class Solution {
    public int bestClosingTime(String customers) {
        int n = customers.length();
        int penality = 0;

        int minPenality = 0, res = 0;
        for (int i = 0; i < n; i++) {
            penality = penality + (customers.charAt(i) == 'N'? 1: -1);
            if (penality < minPenality) {
                minPenality = penality;
                res = i+1;
            }
        }
        return res;
    }
}
```