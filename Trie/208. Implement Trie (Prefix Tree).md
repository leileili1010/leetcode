# 208. Implement Trie (Prefix Tree)

- time O(N)
- space O(N)

## Approach 1 - 用HashMap来实现Trie

```java
class TrieNode {
    public Map<Character, TrieNode> children;
    public boolean isWord;
    public String word;

    public TrieNode() {
        children = new HashMap<>();
        isWord = false;
        word = null;
    }
}

class Trie {
    TrieNode root;

    public Trie() {
        root = new TrieNode();
    }
    
    public void insert(String word) { // O(L)
       TrieNode node = root; 
       
       for (char letter: word.toCharArray()) {
            if (!node.children.containsKey(letter)) {
                node.children.put(letter, new TrieNode());
            }    
            node = node.children.get(letter);
        }
        node.isWord = true;
        node.word = word;
    }
    
    public boolean search(String word) { // 没有. O(L), 有点 O(16 * L)
        TrieNode node = root;
        for (char letter: word.toCharArray()) {
            if (!node.children.containsKey(letter)) {
                return false;
            }
            node = node.children.get(letter);
        }
        return node.isWord; // must return isWord instead returning true
    }
    
    public boolean startsWith(String prefix) {
        TrieNode node = root;

        for (char letter: prefix.toCharArray()) {
            if (!node.children.containsKey(letter)) {
                return false;
            }
            node = node.children.get(letter);
        }
        return true; // just returning true is fine
    }

}
```

## Approach 2 - 用数组实现Trie (最优解)

```java
class Trie {
    private static class Node {
        Node[] son = new Node[26];
        boolean end = false;
    }

    private final Node root = new Node();

    public void insert(String word) {
        Node cur = root;
        for (char c : word.toCharArray()) {
            c -= 'a';
            if (cur.son[c] == null) { // 无路可走？
                cur.son[c] = new Node(); // new 出来！
            }
            cur = cur.son[c];
        }
        cur.end = true;
    }

    public boolean search(String word) {
        return find(word) == 2;
    }

    public boolean startsWith(String prefix) {
        return find(prefix) != 0;
    }

    private int find(String word) {
        Node cur = root;
        for (char c : word.toCharArray()) {
            c -= 'a';
            if (cur.son[c] == null) { // 道不同，不相为谋
                return 0;
            }
            cur = cur.son[c];
        }
        // 走过同样的路（2=完全匹配，1=前缀匹配）
        return cur.end ? 2 : 1;
    }
}

```

- 另一种我自己的写法参考上面的版本

```java
class TrieNode {
    TrieNode[] children;
    boolean isWord;

    TrieNode() {
        children = new TrieNode[26];
        isWord = false;
    }
}
class Trie {
    private TrieNode root;

    public Trie() {
        root = new TrieNode();    
    }
    
    public void insert(String word) { // O(L)
        TrieNode node = root;
        for (char c: word.toCharArray()) {
            c -= 'a';
            if (node.children[c] == null) {
                node.children[c] = new TrieNode();
            }
            node = node.children[c];
        }
        node.isWord = true;
    }
    
    public boolean search(String word) { // O(L)
        return find(word) == 2;
    }
    
    public boolean startsWith(String prefix) { // // O(L)
        return find(prefix) != 0;
    }

    private int find(String word) {
        TrieNode node = root;
        for (char c: word.toCharArray()) {
            c -= 'a';
            if (node.children[c] == null) return 0;
            node = node.children[c]; 
        }
        return node.isWord? 2: 1; // 2-match word, 1-match prefix
    }
}
```

- time： O(L)
- space: O(26 * L * N) ~ O(N * L)