# 1166. Design File System

## Approach 1 - HashMap
这道题写HashMap更简单 但是因为file system其实是tree结构 有可能面试官会要求你写Trie

- Time: O(1)
- 空间： O(N)

```java
class FileSystem {
    Map<String, Integer> map; 

    public FileSystem() {
        map = new HashMap<>();
    }
    
    public boolean createPath(String path, int value) {
        // Coner case (mentioned in the problem)
        if (path.isEmpty() || path.equals("/")) return false;

        // check if already exists
        if (map.containsKey(path)) return false;

        // check if parent exists only when creating nested path
        int lastSlashIndex = path.lastIndexOf("/");
        String parent = path.substring(0, lastSlashIndex);

        // if we are creating parent path "/leetcode", parent = "", are both valid
        // so we only check parent when parent.length > 0
        // 这里我们写 > 1, 其实parent = "/"不可能出现，但语义上代表 root， 不能算错
        if (parent.length() > 1 && !map.containsKey(parent)) return false; 
       
       // Valid case
        map.put(path, value);
        return true;
    }
    
    public int get(String path) { // O(1)
        return map.getOrDefault(path, -1);
    }
}
```

## Approach 2 - Trie

![alt text](image.png)

```java
class TrieNode {
    public Map<String, TrieNode> children;
    public int val;

    public TrieNode(int val) {
        this.val = val;
        children = new HashMap<>();
    }
}

class FileSystem {
    TrieNode root;

    public FileSystem() {
        root = new TrieNode(-1);
    }
    
    public boolean createPath(String path, int value) {
        // corner case
        if (path.isEmpty() || path.equals("/")) return false;

        // check if parents exist
        TrieNode node = root;
        String[] words = path.split("/"); // ["", "leetcode", "problems"]
        int n = words.length;

        for (int i = 1; i < n-1; i++) { // only check parents
            String word = words[i];
            if (!node.children.containsKey(word)) return false;
            node = node.children.get(word);
        }

        // check if path exists
        String last = words[n-1];
        if (node.children.containsKey(last)) return false;

        // create path
        node.children.put(last, new TrieNode(value));
        return true;
    }
    
    public int get(String path) {
        // corner case
        if (path.isEmpty() || path.equals("/")) return -1;

        TrieNode node = root;
        String[] words = path.split("/"); // ["", "leetcode", "problems"]
        int n = words.length;

        for (int i = 1; i < n; i++) {
            String word = words[i];
            if (!node.children.containsKey(word)) return -1;
            node = node.children.get(word);
        }

        return node.val;
    }
}
```